#!/usr/bin/bash
# This file is in the public domain.

aur_install()
{
	cd /tmp || exit
	# Clean up possible interrupted install
	rm -Rf "$1"
	curl "https://aur.archlinux.org/cgit/aur.git/snapshot/$1.tar.gz" | tar xz
	chown nobody "$1"
	chgrp nobody "$1"
	cd "$1" || exit
	# Run makepkg as nobody, so it doesn't complain about running as root (and also without breaking the rules and using fakeroot)
	# pass "-si" with set, and pass the name of the script as an argument so that $0 points to the name of the script (used for fakeroot)
	# Hook into the script by overriding su and sudo so that commands that require root privileges (installing packages) are tagged and sent to this script for modification/execution
	# Stop the script with a blocking read while executing, and let the script move on by passing to it's fifo input.
	mkfifo makepkg_comm
	# TODO: Need return values for su/sudo functions
	tail -f makepkg_comm | su nobody -s /usr/bin/bash -c \
"function su { set -- "\$@"; echo "makepkg_execute\ \${@:3}"; read line; }\
;function sudo { set -- "\$@"; echo "makepkg_execute\ \${@:1}"; read line; }\
;function exit { echo "makepkg_exit\ \$1"; command exit \$1; }\
;set -- -si;source /usr/bin/makepkg" /usr/bin/makepkg |
	{
		while IFS= read -r line; do
			if [[ "${line}" =~ makepkg_execute.* ]]; then
				# TODO: Handle AUR dependencies
				echo "Executing from puckman: ${line#* }"
				# Read input from the user, not from makepkg, otherwise prompts from pacman will not work
				/usr/bin/bash -c "${line#* }" <&1
				echo "" > makepkg_comm
			elif [[ "${line}" =~ makepkg_exit.* ]]; then
				# Kill the tail so we can move on
				pkill -9 -P $$ tail
				break
			else
				echo "${line}"
			fi
		done
	}
	cd /tmp || exit
	rm -Rf "$1"
}

usage="Usage: puckman [update,install,remove,clean,list,upgrade]\n\n\
puckman update            == pacman -Sy\n\
puckman install <package> == pacman -S <package>\n\
puckman remove  <package> == pacman -Rsc <package>\n\
puckman clean             == Remove orphan packages and cached packages that are not installed\n\
puckman upgrade           == pacman -Syu\n\
puckman list              == List explicitly installed packages"

# Determine if we need superuser privileges
if [[ $EUID -ne 0 ]]; then
	case "$1" in
		update|install|remove|clean|upgrade)
			if type -p sudo >/dev/null; then
				sudo "$0" "$@"
			else
				su root -c "$0 $*"
			fi
			exit
			;;
	esac
fi

case "$1" in
	update)
		pacman -Sy
		echo "Updating AUR package list..."
		# Wanted to be efficient and use wget's timestamp option (-N), but AUR doesnt use the Last-modified header
		curl https://aur.archlinux.org/packages.gz | gzip -d > /var/lib/puckman/aur_packages
		;;
	install)
		if [[ -z "$2" ]]; then
			echo -e "${usage}"
		else
			# Determine whether this package is in the AUR package list, if not assume official
			if grep -Fxq "$2" /var/lib/puckman/aur_packages 2>/dev/null; then
				aur_install "$2"
			else
				pacman -Sy "$2"
			fi
		fi
		;;
	remove)
		if [[ -z "$2" ]]; then
			echo -e "${usage}"
		else
			pacman -Rsc "$2"
		fi
		;;
	clean)
		orphans="$(pacman -Qqdt)"
		if [[ -z "${orphans}" ]]; then
			echo "No orphans to clean!"
		else
			pacman -Rsc ${orphans}
		fi
		pacman -Sc
		;;
	upgrade)
		pacman -Syu
		;;
	list)
		pacman -Qei | awk '/^Name/ { name=$3 } /^Groups/ { if ( $3 != "base" && $3 != "base-devel" ) { print name } }'
		;;
	*)
		echo -e "${usage}"
		;;

esac
